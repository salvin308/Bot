import os
import logging
import random
import asyncio
from Script import script
from .fonts import Fonts
from pyrogram import Client, filters
from pyrogram.errors import ChatAdminRequired, FloodWait
from pyrogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from database.ia_filterdb import Media, get_file_details, unpack_new_file_id
from database.users_chats_db import db
from info import CHANNELS, ADMINS, AUTH_CHANNEL, LOG_CHANNEL, PICS, CUSTOM_FILE_CAPTION, BATCH_FILE_CAPTION, PROTECT_CONTENT
from utils import get_settings, get_size, is_subscribed, save_group_settings, temp
from database.connections_mdb import active_connection
import re
import json
import base64
logger = logging.getLogger(__name__)

BATCH_FILES = {}

@Client.on_message(filters.command("start"))
async def start(client, message):
    await message.reply_chat_action("typing")
    await asyncio.sleep(2)
    if message.chat.type in ['group', 'supergroup']:
        buttons = [
            [
                InlineKeyboardButton('Support', url='https://t.me/SS_ADMIN_308_bot')
            ]
            ]
        reply_markup = InlineKeyboardMarkup(buttons)
        reply_markup = InlineKeyboardMarkup(buttons)
        await message.reply(script.PRIVATEBOT_TXT.format(message.from_user.mention if message.from_user else message.chat.title, temp.U_NAME, temp.B_NAME), reply_markup=reply_markup)
        await asyncio.sleep(2)
        if not await db.get_chat(message.chat.id):
            total=await client.get_chat_members_count(message.chat.id)
            await client.send_message(LOG_CHANNEL, script.LOG_TEXT_G.format(message.chat.title, message.chat.id, total, "Unknown"))       
            await db.add_chat(message.chat.id, message.chat.title)
        return 
    if not await db.is_user_exist(message.from_user.id):
        await db.add_user(message.from_user.id, message.from_user.first_name)
        await client.send_message(LOG_CHANNEL, script.LOG_TEXT_P.format(message.from_user.id, message.from_user.mention))
    if len(message.command) != 2:
        buttons = [[
            InlineKeyboardButton('üîç s·¥á·¥Ä Ä·¥Ñ ú  ú·¥á Ä·¥á ·¥ç·¥è·¥†…™·¥á üîé', switch_inline_query_current_chat='')
            ],[
            InlineKeyboardButton('üë• Movie Group üë•', url='https://t.me/SS_Movie_Club'),
            InlineKeyboardButton('üóØ CONTACT DEV üóØ', url='https://t.me/SS_ADMIN_308_bot')
            ],[
            InlineKeyboardButton('üìÉ ALL FEATURES LIST üìÉ', callback_data='features')
            ],[
            InlineKeyboardButton('‚ö† HŒûL·éÆ ‚ö†', callback_data='help_1'),
            InlineKeyboardButton('ü§† ŒõBOUT ü§†', callback_data='about')
            ],[
            InlineKeyboardButton('üîê CLOSE üîê', callback_data='close_data')
        ]]
        reply_markup = InlineKeyboardMarkup(buttons)
        await message.reply_photo(
            photo=random.choice(PICS),
            caption=script.START_TXT.format(message.from_user.mention, temp.U_NAME, temp.B_NAME),
            reply_markup=reply_markup,
            parse_mode='html'
        )
        return
    if AUTH_CHANNEL and not await is_subscribed(client, message):
        try:
            invite_link = await client.create_chat_invite_link(int(AUTH_CHANNEL))
        except ChatAdminRequired:
            logger.error("Make sure Bot is admin in Forcesub channel")
            return
        btn = [
            [
                InlineKeyboardButton(
                    "üî• Join this Channel üî•", url=invite_link.invite_link
                )
            ]
        ]

        if message.command[1] != "subscribe":
            btn.append([InlineKeyboardButton("üîÅ Try Agin üîÅ", callback_data=f"checksub#{message.command[1]}")])
        await client.send_message(
            chat_id=message.from_user.id,
            text="**Join this Group to use me!**",
            reply_markup=InlineKeyboardMarkup(btn),
            parse_mode="markdown"
            )
        return
    if len(message.command) ==2 and message.command[1] in ["subscribe", "error", "okay", "help_1"]:
        buttons = [[
            InlineKeyboardButton('üîç s·¥á·¥Ä Ä·¥Ñ ú  ú·¥á Ä·¥á ·¥ç·¥è·¥†…™·¥á üîé', switch_inline_query_current_chat='')
            ],[
            InlineKeyboardButton('üë• Movie Group üë•', url='https://t.me/SS_Movie_Club'),
            InlineKeyboardButton('üóØ CONTACT DEV üóØ', url='https://t.me/SS_ADMIN_308_bot')
            ],[
            InlineKeyboardButton('üìÉ ALL FEATURES LIST üìÉ', callback_data='features')
            ],[
            InlineKeyboardButton('‚ö† HŒûL·éÆ ‚ö†', callback_data='help_1'),
            InlineKeyboardButton('ü§† ŒõBOUT ü§†', callback_data='about')
            ],[
            InlineKeyboardButton('üîê CLOSE üîê', callback_data='close_data')
        ]]
        reply_markup = InlineKeyboardMarkup(buttons)
        await message.reply_photo(
            photo=random.choice(PICS),
            caption=script.START_TXT.format(message.from_user.mention, temp.U_NAME, temp.B_NAME),
            reply_markup=reply_markup,
            parse_mode='html'
        )
        return
    data = message.command[1]
    try:
        pre, file_id = data.split('_', 1)
    except:
        file_id = data
        pre = ""
    if data.split("-", 1)[0] == "BATCH":
        sts = await message.reply_sticker("CAACAgUAAxkBAAIYeGLkA79wEhAQBIPNscY7zCSAJGHQAAKlAAPIlGQUeEOFXgFFtkYeBA")
        file_id = data.split("-", 1)[1]
        msgs = BATCH_FILES.get(file_id)
        if not msgs:
            file = await client.download_media(file_id)
            try: 
                with open(file) as file_data:
                    msgs=json.loads(file_data.read())
            except:
                await sts.edit("FAILED")
                return await client.send_message(LOG_CHANNEL, "UNABLE TO OPEN FILE.")
            os.remove(file)
            BATCH_FILES[file_id] = msgs
        for msg in msgs:
            title = msg.get("title")
            size=get_size(int(msg.get("size", 0)))
            f_caption=msg.get("caption", "")
            if BATCH_FILE_CAPTION:
                try:
                    f_caption=BATCH_FILE_CAPTION.format(file_name= '' if title is None else title, file_size='' if size is None else size, file_caption='' if f_caption is None else f_caption)
                except Exception as e:
                    logger.exception(e)
                    f_caption=f_caption
            if f_caption is None:
                f_caption = f"{title}"
            try:
                await client.send_cached_media(
                    chat_id=message.from_user.id,
                    file_id=msg.get("file_id"),
                    caption=f_caption,
                    protect_content=msg.get('protect', False),
                    )
            except FloodWait as e:
                await asyncio.sleep(e.x)
                logger.warning(f"Floodwait of {e.x} sec.")
                await client.send_cached_media(
                    chat_id=message.from_user.id,
                    file_id=msg.get("file_id"),
                    caption=f_caption,
                    protect_content=msg.get('protect', False),
                    )
            except Exception as e:
                logger.warning(e, exc_info=True)
                continue
            await asyncio.sleep(1) 
        await sts.delete()
        return
    elif data.split("-", 1)[0] == "DSTORE":
        sts = await message.reply_sticker("CAACAgUAAxkBAAIYeGLkA79wEhAQBIPNscY7zCSAJGHQAAKlAAPIlGQUeEOFXgFFtkYeBA")
        b_string = data.split("-", 1)[1]
        decoded = (base64.urlsafe_b64decode(b_string + "=" * (-len(b_string) % 4))).decode("ascii")
        try:
            f_msg_id, l_msg_id, f_chat_id, protect = decoded.split("_", 3)
        except:
            f_msg_id, l_msg_id, f_chat_id = decoded.split("_", 2)
            protect = "/pbatch" if PROTECT_CONTENT else "batch"
        diff = int(l_msg_id) - int(f_msg_id)
        async for msg in client.iter_messages(int(f_chat_id), int(l_msg_id), int(f_msg_id)):
            if msg.media:
                media = getattr(msg, msg.media)
                if BATCH_FILE_CAPTION:
                    try:
                        f_caption=BATCH_FILE_CAPTION.format(file_name=getattr(media, 'file_name', ''), file_size=getattr(media, 'file_size', ''), file_caption=getattr(msg, 'caption', ''))
                    except Exception as e:
                        logger.exception(e)
                        f_caption = getattr(msg, 'caption', '')
                else:
                    media = getattr(msg, msg.media)
                    file_name = getattr(media, 'file_name', '')
                    f_caption = getattr(msg, 'caption', file_name)
                try:
                    await msg.copy(message.chat.id, caption=f_caption, protect_content=True if protect == "/pbatch" else False)
                except FloodWait as e:
                    await asyncio.sleep(e.x)
                    await msg.copy(message.chat.id, caption=f_caption, protect_content=True if protect == "/pbatch" else False)
                except Exception as e:
                    logger.exception(e)
                    continue
            elif msg.empty:
                continue
            else:
                try:
                    await msg.copy(message.chat.id, protect_content=True if protect == "/pbatch" else False)
                except FloodWait as e:
                    await asyncio.sleep(e.x)
                    await msg.copy(message.chat.id, protect_content=True if protect == "/pbatch" else False)
                except Exception as e:
                    logger.exception(e)
                    continue
            await asyncio.sleep(1) 
        return await sts.delete()

    files_ = await get_file_details(file_id)           
    if not files_:
        pre, file_id = ((base64.urlsafe_b64decode(data + "=" * (-len(data) % 4))).decode("ascii")).split("_", 1)
        try:
            msg = await client.send_cached_media(
                chat_id=message.from_user.id,
                file_id=file_id,
                protect_content=True if pre == 'filep' else False,
                )
            filetype = msg.media
            file = getattr(msg, filetype)
            title = file.file_name
            size=get_size(file.file_size)
            f_caption = f"<code>{title}</code>"
            if CUSTOM_FILE_CAPTION:
                try:
                    f_caption=CUSTOM_FILE_CAPTION.format(file_name= '' if title is None else title, file_size='' if size is None else size, file_caption='')
                except:
                    return
            await msg.edit_caption(f_caption)
            return
        except:
            pass
        return await message.reply('No such file exist.')
    files = files_[0]
    title = files.file_name
    size=get_size(files.file_size)
    f_caption=files.caption
    if CUSTOM_FILE_CAPTION:
        try:
            f_caption=CUSTOM_FILE_CAPTION.format(file_name= '' if title is None else title, file_size='' if size is None else size, file_caption='' if f_caption is None else f_caption)
        except Exception as e:
            logger.exception(e)
            f_caption=f_caption
    if f_caption is None:
        f_caption = f"{files.file_name}"
    await client.send_cached_media(
        chat_id=message.from_user.id,
        file_id=file_id,
        caption=f_caption,
        protect_content=True if pre == 'filep' else False,
        )
                    

@Client.on_message(filters.command('channel') & filters.user(ADMINS))
async def channel_info(bot, message):
    await message.reply_chat_action("typing")
           
    """Send basic information of channel"""
    if isinstance(CHANNELS, (int, str)):
        channels = [CHANNELS]
    elif isinstance(CHANNELS, list):
        channels = CHANNELS
    else:
        raise ValueError("Unexpected type of CHANNELS")

    text = 'üìë **Indexed channels/groups**\n'
    for channel in channels:
        chat = await bot.get_chat(channel)
        if chat.username:
            text += '\n@' + chat.username
        else:
            text += '\n' + chat.title or chat.first_name

    text += f'\n\n**Total:** {len(CHANNELS)}'

    if len(text) < 4096:
        await message.reply(text)
    else:
        file = 'Indexed channels.txt'
        with open(file, 'w') as f:
            f.write(text)
        await message.reply_document(file)
        os.remove(file)


@Client.on_message(filters.command('logs') & filters.user(ADMINS))
async def log_file(bot, message):
    await message.reply_chat_action("typing")
    """Send log file"""
    try:
        await message.reply_document('TelegramBot.log')
    except Exception as e:
        await message.reply(str(e))

@Client.on_message(filters.command('delete') & filters.user(ADMINS))
async def delete(bot, message):
    await message.reply_chat_action("typing")
    """Delete file from database"""
    reply = message.reply_to_message
    if reply and reply.media:
        msg = await message.reply("Deleting....üóëÔ∏è", quote=True)
    else:
        await message.reply('Reply to file with /delete which you want to delete', quote=True)
        return

    for file_type in ("document", "video", "audio"):
        media = getattr(reply, file_type, None)
        if media is not None:
            break
    else:
        await msg.edit('This is not supported file format')
        return
    
    file_id, file_ref = unpack_new_file_id(media.file_id)

    result = await Media.collection.delete_one({
        '_id': file_id,
    })
    if result.deleted_count:
        await msg.edit('**FILE SUCCESSFULLY DELETED**')
    else:
        file_name = re.sub(r"(_|\-|\.|\+)", " ", str(media.file_name))
        result = await Media.collection.delete_many({
            'file_name': file_name,
            'file_size': media.file_size,
            'mime_type': media.mime_type
            })
        if result.deleted_count:
            await msg.edit('**FILE SUCCESSFULLY DELETED**')
        else:
            # files indexed before https://github.com/EvamariaTG/EvaMaria/commit/f3d2a1bcb155faf44178e5d7a685a1b533e714bf#diff-86b613edf1748372103e94cacff3b578b36b698ef9c16817bb98fe9ef22fb669R39 
            # have original file name.
            result = await Media.collection.delete_many({
                'file_name': media.file_name,
                'file_size': media.file_size,
                'mime_type': media.mime_type
            })
            if result.deleted_count:
                await msg.edit('**FILE SUCCESSFULLY DELETED**')
            else:
                await msg.edit('File not found in database')


@Client.on_message(filters.command('deleteall') & filters.user(ADMINS))
async def delete_all_index(bot, message):
    await message.reply_text(
        '**THIS PROCESS WILL DELETE ALL THE FILES FROM YOUR DATABASE.\nDO YOU WANT TO CONTINUE THIS..??**',
        reply_markup=InlineKeyboardMarkup(
            [
                [
                    InlineKeyboardButton(
                        text="‚ö° Yes ‚ö°", callback_data="autofilter_delete"
                    )
                ],
                [
                    InlineKeyboardButton(
                        text="‚ùÑ Cancle ‚ùÑ", callback_data="close_data"
                    )
                ],
            ]
        ),
        quote=True,
    )


@Client.on_callback_query(filters.regex(r'^autofilter_delete'))
async def delete_all_index_confirm(bot, message):
    await Media.collection.drop()
    await message.answer('PLEASE SHARE AND SUPPORT')
    await message.message.edit('Succesfully Deleted All The Indexed Files.')


@Client.on_message(filters.command('settings'))
async def settings(client, message):
    await message.reply_chat_action("typing")
    userid = message.from_user.id if message.from_user else None
    if not userid:
        return await message.reply(f"You are anonymous admin. Use /connect {message.chat.id} in PM")
    chat_type = message.chat.type

    if chat_type == "private":
        grpid = await active_connection(str(userid))
        if grpid is not None:
            grp_id = grpid
            try:
                chat = await client.get_chat(grpid)
                title = chat.title
            except:
                await message.reply_text("Make sure I'm present in your group!!", quote=True)
                return
        else:
            await message.reply_text("I'm not connected to any groups!", quote=True)
            return

    elif chat_type in ["group", "supergroup"]:
        grp_id = message.chat.id
        title = message.chat.title

    else:
        return

    st = await client.get_chat_member(grp_id, userid)
    if (
            st.status != "administrator"
            and st.status != "creator"
            and str(userid) not in ADMINS
    ):
        return

    settings = await get_settings(grp_id)

    if settings is not None:
        buttons = [
            [
                InlineKeyboardButton(
                    'Filter Buttons',
                    callback_data=f'setgs#button#{settings["button"]}#{grp_id}',
                ),
                InlineKeyboardButton(
                    'SINGLE' if settings["button"] else 'DOUBLE',
                    callback_data=f'setgs#button#{settings["button"]}#{grp_id}',
                ),
            ],
            [
                InlineKeyboardButton(
                    'BOT PM',
                    callback_data=f'setgs#botpm#{settings["botpm"]}#{grp_id}',
                ),
                InlineKeyboardButton(
                    '‚úÖ YES' if settings["botpm"] else 'üóëÔ∏è NO',
                    callback_data=f'setgs#botpm#{settings["botpm"]}#{grp_id}',
                ),
            ],
            [
                InlineKeyboardButton(
                    'FILE SECURE',
                    callback_data=f'setgs#file_secure#{settings["file_secure"]}#{grp_id}',
                ),
                InlineKeyboardButton(
                    '‚úÖ YES' if settings["file_secure"] else 'üóëÔ∏è NO',
                    callback_data=f'setgs#file_secure#{settings["file_secure"]}#{grp_id}',
                ),
            ],
            [
                InlineKeyboardButton(
                    'IMDB IMAGE',
                    callback_data=f'setgs#imdb#{settings["imdb"]}#{grp_id}',
                ),
                InlineKeyboardButton(
                    '‚úÖ YES' if settings["imdb"] else 'üóëÔ∏è NO',
                    callback_data=f'setgs#imdb#{settings["imdb"]}#{grp_id}',
                ),
            ],
            [
                InlineKeyboardButton(
                    'SPELL CHECK',
                    callback_data=f'setgs#spell_check#{settings["spell_check"]}#{grp_id}',
                ),
                InlineKeyboardButton(
                    '‚úÖ YES' if settings["spell_check"] else 'üóëÔ∏è NO',
                    callback_data=f'setgs#spell_check#{settings["spell_check"]}#{grp_id}',
                ),
            ],
            [
                InlineKeyboardButton(
                    'WELCOME',
                    callback_data=f'setgs#welcome#{settings["welcome"]}#{grp_id}',
                ),
                InlineKeyboardButton(
                    '‚úÖ YES' if settings["welcome"] else 'üóëÔ∏è NO',
                    callback_data=f'setgs#welcome#{settings["welcome"]}#{grp_id}',
                ),
            ],
            [
                InlineKeyboardButton('üîê CLOSE üîê', callback_data='close_data')
            ],
        ]

        reply_markup = InlineKeyboardMarkup(buttons)

        await message.reply_text(
            text=f"<b>CHANGE THE BOT SETTINGS FOR {title}../</b>",
            reply_markup=reply_markup,
            disable_web_page_preview=True,
            parse_mode="html",
            reply_to_message_id=message.message_id
        )



@Client.on_message(filters.command('set_template'))
async def save_template(client, message):
    await message.reply_chat_action("typing")
    sts = await message.reply('<b>Loading ...</b>')
    userid = message.from_user.id if message.from_user else None
    if not userid:
        return await message.reply(f"You are anonymous admin. Use /connect {message.chat.id} in PM")
    chat_type = message.chat.type

    if chat_type == "private":
        grpid = await active_connection(str(userid))
        if grpid is not None:
            grp_id = grpid
            try:
                chat = await client.get_chat(grpid)
                title = chat.title
            except:
                await message.reply_text("Make sure I'm present in your group!!", quote=True)
                return
        else:
            await message.reply_text("I'm not connected to any groups!", quote=True)
            return

    elif chat_type in ["group", "supergroup"]:
        grp_id = message.chat.id
        title = message.chat.title

    else:
        return

    st = await client.get_chat_member(grp_id, userid)
    if (
            st.status != "administrator"
            and st.status != "creator"
            and str(userid) not in ADMINS
    ):
        return

    if len(message.command) < 2:
        return await sts.edit("No Input!!")
    template = message.text.split(" ", 1)[1]
    await save_group_settings(grp_id, 'template', template)
    await sts.edit(f"SUCCESSFULLY UPGRADED YOUR TEMPLATE FOR {title}\n\n{template}")
    
    
@Client.on_message(filters.private & filters.incoming & filters.text)
async def style_buttons(c, m, cb=False):
    buttons = [[
        InlineKeyboardButton('ùöÉùö¢ùöôùöéùö†ùöõùöíùöùùöéùöõ', callback_data='style+typewriter'),
        InlineKeyboardButton('ùïÜùï¶ùï•ùïùùïöùïüùïñ', callback_data='style+outline'),
        InlineKeyboardButton('ùêíùêûùê´ùê¢ùêü', callback_data='style+serif'),
        ],[
        InlineKeyboardButton('ùë∫ùíÜùíìùíäùíá', callback_data='style+bold_cool'),
        InlineKeyboardButton('ùëÜùëíùëüùëñùëì', callback_data='style+cool'),
        InlineKeyboardButton('S·¥ç·¥Ä ü ü C·¥Ä·¥òs', callback_data='style+small_cap'),
        ],[
        InlineKeyboardButton('ùìàùí∏ùìáùíæùìÖùìâ', callback_data='style+script'),
        InlineKeyboardButton('ùìºùì¨ùìªùì≤ùìπùìΩ', callback_data='style+script_bolt'),
        InlineKeyboardButton('·µó‚Å±‚Åø ∏', callback_data='style+tiny'),
        ],[
        InlineKeyboardButton('·ëïO·ó∞I·ëï', callback_data='style+comic'),
        InlineKeyboardButton('ùó¶ùóÆùóªùòÄ', callback_data='style+sans'),
        InlineKeyboardButton('ùôéùôñùô£ùô®', callback_data='style+slant_sans'),
        ],[
        InlineKeyboardButton('ùòöùò¢ùòØùò¥', callback_data='style+slant'),
        InlineKeyboardButton('ùñ≤ùñ∫ùóáùóå', callback_data='style+sim'),
         InlineKeyboardButton('‚í∏Ô∏é‚íæÔ∏é‚ìáÔ∏é‚í∏Ô∏é‚ìÅÔ∏é‚í∫Ô∏é‚ìàÔ∏é', callback_data='style+circles'),
        ],[
        InlineKeyboardButton('üÖíÔ∏éüÖòÔ∏éüÖ°Ô∏éüÖíÔ∏éüÖõÔ∏éüÖîÔ∏éüÖ¢Ô∏é', callback_data='style+circle_dark'),
        InlineKeyboardButton('ùîäùî¨ùî±ùî•ùî¶ùî†', callback_data='style+gothic'),
        InlineKeyboardButton('ùï≤ùñîùñôùñçùñéùñà', callback_data='style+gothic_bolt'),
        ],[
        InlineKeyboardButton('CÕ°ÕúlÕ°ÕúoÕ°ÕúuÕ°ÕúdÕ°ÕúsÕ°Õú', callback_data='style+cloud'),
        InlineKeyboardButton('HÃÜÃàaÃÜÃàpÃÜÃàpÃÜÃàyÃÜÃà', callback_data='style+happy'),
        InlineKeyboardButton('SÃëÃàaÃëÃàdÃëÃà', callback_data='style+sad'),
        ],[
        InlineKeyboardButton('Next ‚û°Ô∏è', callback_data="nxt")
        ],[
        InlineKeyboardButton('üá∏‚Ääüáµ‚Ääüá™‚Ääüá®‚ÄäüáÆ‚Ääüá¶‚Ääüá±‚Ää', callback_data='style+special'),
        InlineKeyboardButton('üÖÇüÖÄüÖÑüÑ∞üÖÅüÑ¥üÖÇ', callback_data='style+squares'),
        InlineKeyboardButton('üÜÇÔ∏éüÜÄÔ∏éüÜÑÔ∏éüÖ∞Ô∏éüÜÅÔ∏éüÖ¥Ô∏éüÜÇÔ∏é', callback_data='style+squares_bold'),
        ],[
        InlineKeyboardButton('Í™ñÍ™Ä·¶îÍ™ñÍ™∂Í™ä·•¥ùì≤Í™ñ', callback_data='style+andalucia')
        InlineKeyboardButton('Áà™ÂçÇÂá†·òúÂçÇ', callback_data='style+manga'),
        InlineKeyboardButton('SÃætÃæiÃænÃækÃæyÃæ', callback_data='style+stinky'),
        ],[
        InlineKeyboardButton('BÕ¶Ã•uÕ¶Ã•bÕ¶Ã•bÕ¶Ã•lÕ¶Ã•eÕ¶Ã•sÕ¶Ã•', callback_data='style+bubbles'),
        InlineKeyboardButton('UÕünÕüdÕüeÕürÕülÕüiÕünÕüeÕü', callback_data='style+underline'),
        InlineKeyboardButton('ÍííÍçèÍÄ∑Íå©ÍåÉÍÄéÍÅÖ', callback_data='style+ladybug'),
        ],[
        InlineKeyboardButton('R“âa“ây“âs“â', callback_data='style+rays'),
        InlineKeyboardButton('B“ài“àr“àd“às“à', callback_data='style+birds'),
        InlineKeyboardButton('SÃ∏lÃ∏aÃ∏sÃ∏hÃ∏', callback_data='style+slash'),
        ],[
        InlineKeyboardButton('s‚É†t‚É†o‚É†p‚É†', callback_data='style+stop'),
        InlineKeyboardButton('SÕÜÃ∫kÕÜÃ∫yÕÜÃ∫lÕÜÃ∫iÕÜÃ∫nÕÜÃ∫eÕÜÃ∫', callback_data='style+skyline'),
        InlineKeyboardButton('AÕérÕérÕéoÕéwÕésÕé', callback_data='style+arrows'),
        ],[
        InlineKeyboardButton('·ã™·àÄ·ä≠·âø·äê', callback_data='style+qvnes'),
        InlineKeyboardButton('SÃ∂tÃ∂rÃ∂iÃ∂kÃ∂eÃ∂', callback_data='style+strike'),
        InlineKeyboardButton('F‡ºôr‡ºôo‡ºôz‡ºôe‡ºôn‡ºô', callback_data='style+frozen')
    ]]
    if not cb:
        await m.reply_text(m.text, reply_markup=InlineKeyboardMarkup(buttons), quote=True)
    else:
        await m.answer()
        await m.message.edit_reply_markup(InlineKeyboardMarkup(buttons))


@Client.on_callback_query(filters.regex('^style'))
async def style(c, m):
    await m.answer()
    cmd, style = m.data.split('+')

    if style == 'typewriter':
        cls = Fonts.typewriter
    if style == 'outline':
        cls = Fonts.outline
    if style == 'serif':
        cls = Fonts.serief
    if style == 'bold_cool':
        cls = Fonts.bold_cool
    if style == 'cool':
        cls = Fonts.cool
    if style == 'small_cap':
        cls = Fonts.smallcap
    if style == 'script':
        cls = Fonts.script
    if style == 'script_bolt':
        cls = Fonts.bold_script
    if style == 'tiny':
        cls = Fonts.tiny
    if style == 'comic':
        cls = Fonts.comic
    if style == 'sans':
        cls = Fonts.san
    if style == 'slant_sans':
        cls = Fonts.slant_san
    if style == 'slant':
        cls = Fonts.slant
    if style == 'sim':
        cls = Fonts.sim
    if style == 'circles':
        cls = Fonts.circles
    if style == 'circle_dark':
        cls = Fonts.dark_circle
    if style == 'gothic':
        cls = Fonts.gothic
    if style == 'gothic_bolt':
        cls = Fonts.bold_gothic
    if style == 'cloud':
        cls = Fonts.cloud
    if style == 'happy':
        cls = Fonts.happy
    if style == 'sad':
        cls = Fonts.sad
    if style == 'special':
        cls = Fonts.special
    if style == 'squares':
        cls = Fonts.square
    if style == 'squares_bold':
        cls = Fonts.dark_square
    if style == 'andalucia':
        cls = Fonts.andalucia
    if style == 'manga':
        cls = Fonts.manga
    if style == 'stinky':
        cls = Fonts.stinky
    if style == 'bubbles':
        cls = Fonts.bubbles
    if style == 'underline':
        cls = Fonts.underline
    if style == 'ladybug':
        cls = Fonts.ladybug
    if style == 'rays':
        cls = Fonts.rays
    if style == 'birds':
        cls = Fonts.birds
    if style == 'slash':
        cls = Fonts.slash
    if style == 'stop':
        cls = Fonts.stop
    if style == 'skyline':
        cls = Fonts.skyline
    if style == 'arrows':
        cls = Fonts.arrows
    if style == 'qvnes':
        cls = Fonts.rvnes
    if style == 'strike':
        cls = Fonts.strike
    if style == 'frozen':
        cls = Fonts.frozen
    new_text = cls(m.message.reply_to_message.text)
    try:
        await m.message.edit_text(new_text, reply_markup=m.message.reply_markup)
    except:
        pass
